---
title: يشرح MappingMode و ReferenceMode
type: docs
weight: 10
url: /ar/net/mapping-mode-and-reference-mode-explains
description: باستخدام Aspose.3D for .NET ، يمكن للمطورين تحديد الشبكة بعناصر بيانات فيرتكس مختلفة ، هنا نوضح كيفية تعيين البيانات إلى مكونات الشبكات وإعادة تحليل البيانات.
---
{{% alert color="primary" %}}

باستخدام [Aspose.3D for .NET](https://products.aspose.com/3d/net/) ، يمكن للمطورين تحديد الشبكات بعناصر بيانات فيرتكس مختلفة ، بما في ذلك الأشكال العادية والألوان والأوزان. Aspose. يوفر 3D آليتين لتحسين إعادة استخدام البيانات: `MappingMode` و `ReferenceMode`. تم تصميم هذه الآليات لتقليل أثر ذاكرة الشبكات ، خاصة في التنسيقات المتقدمة مثل FBX و USD. يسمح MappingMode بتخطيط بيانات قمة الرأس بكفاءة لمكونات الشبكة ، بينما يسهل المرجع الرجوع إلى بيانات عنصر قمة الرأس عبر مكونات شبكية متعددة. تعمل هذه الميزات معًا على تحسين الأداء وكفاءة الذاكرة ، مما يجعل Aspose.3D أداة قوية للتعامل مع الطرازات المعقدة 3D في تطبيقات .NET.

{{% /alert %}}



###  `MappingMode` يشرح

 يحدد `MappingMode` كيفية تعيين بيانات العنصر إلى سطح الشكل الهندسي بـ Aspose.3D for .NET. يوفر طرقًا مختلفة لتحديد هذا التعيين:

1. **Cأونت**، يتم تعيين كل عنصر من عناصر البيانات إلى نقطة التحكم في الهندسة. يضمن هذا الوضع أن كل نقطة تحكم ، والتي تحدد شكل الشكل الهندسي ، مرتبطة بعنصر بيانات محدد.
1. **Pأوليغونط إرتكس**، يتم تعيين البيانات إلى قمة المضلع. في الحالات التي يتم فيها مشاركة نقطة التحكم بواسطة مضلعات متعددة ، سيكون لكل مثيل من نقطة التحكم ، كما تظهر في مضلعات مختلفة ، بيانات مميزة خاصة به. وهذا يضمن أنه حتى نقاط التحكم المشتركة يمكن أن تحتوي على بيانات فريدة عندما تكون بمثابة رؤوس لمضلعات مختلفة.
1. **Pأوليغون**، يتم تعيين البيانات إلى المضلع بأكمله. هذا يعني أن جميع رؤوس المضلع تتشارك في عنصر البيانات نفسه. هذا الوضع مفيد عندما تحتاج بيانات موحدة ليتم تطبيقها على سطح المضلع بأكمله ، وضمان الاتساق داخل المضلع.
1. **Eدج**، يتم تعيين البيانات إلى حواف الهندسة. تشترك كل نقطة نهاية للحافة في نفس البيانات ، مما يوفر طريقة لتطبيق بيانات موحدة على الحواف مع السماح بوجود بيانات متميزة لحواف مختلفة. يمكن أن يكون هذا مفيدًا بشكل خاص لتحديد الخصائص الخاصة بالحواف ، مثل قيم التجعيد أو السمات القائمة على الحافة
1. **AllSame**، يتم تعيين عنصر بيانات واحد على كامل سطح الهندسة. بغض النظر عما إذا تم تفسير البيانات كنقاط تحكم أو رؤوس مضلعة أو نقاط نهاية حافة ، يتم تطبيق نفس قيمة البيانات بشكل موحد على جميع العناصر. هذا الوضع مثالي للسيناريوهات التي تحتاج إلى الحفاظ على قيمة ثابتة خلال الهندسة بأكملها ، مما يضمن وجود سمة موحدة عبر نموذج 3D بأكمله.




###  `ReferenceMode` يشرح
 يحدد `ReferenceMode` ما إذا كان سيتم إعادة استخدام البيانات حسب المؤشرات ، وهناك ثلاث سياسات بسعر `ReferenceMode`:

1.**مباشر**، تتم الإشارة إلى البيانات مباشرةً وتخزينها في خاصية `VertexElement` `Data`.
1.**IndextDirect**تتم الإشارة إلى البيانات بواسطة الفهرس ، ثم يتم الوصول إليها بواسطة الفهرس في قائمة بيانات `VertexElement`.
1.**مؤشر**، تتم الإشارة إلى البيانات فقط بواسطة الفهرس ، والآن يستخدم `VertexElementMaterial` فقط هذا الوضع المرجعي ، وهذا مشابه لـ `IndexToDirect` ولكن الاختلافات هي أن المواد محددة ضمن خاصية `Node` `Materials` ، وليس في `VertexElementMaterial` ، جميع `VertexElement` يعمل فقط مع البيانات البدائية.



على سبيل المثال ، يُعطى تعريف المكعب:

{{< highlight "csharp" >}}
var cube = new Mesh();
Vector4[] controlPoints = new Vector4[]
{
    new Vector4( -5.0, 0.0, 5.0, 1.0),
    new Vector4( 5.0, 0.0, 5.0, 1.0),
    new Vector4( 5.0, 10.0, 5.0, 1.0),
    new Vector4( -5.0, 10.0, 5.0, 1.0),
    new Vector4( -5.0, 0.0, -5.0, 1.0),
    new Vector4( 5.0, 0.0, -5.0, 1.0),
    new Vector4( 5.0, 10.0, -5.0, 1.0),
    new Vector4( -5.0, 10.0, -5.0, 1.0)
};
cube.ControlPoints.AddRange(controlPoints);

// Front face (Z+)
cube.CreatePolygon(new int[] { 0, 1, 2, 3 });
// Right side (X+)
cube.CreatePolygon(new int[] { 1, 5, 6, 2 });
// Back face (Z-)
cube.CreatePolygon(new int[] { 5, 4, 7, 6 });
// Left side (X-)
cube.CreatePolygon(new int[] { 4, 0, 3, 7 });
// Bottom face (Y-)
cube.CreatePolygon(new int[] { 0, 4, 5, 1 });
// Top face (Y+)
cube.CreatePolygon(new int[] { 3, 2, 6, 7 });

var vertexColor = (VertexElementVertexColor) cube.CreateElement(VertexElementType.VertexColor);
vertexColor.MappingMode = MappingMode.ControlPoint;
var red = new Vector4(1, 0, 0, 1);
var green = new Vector4(0, 1, 0, 1);
var blue = new Vector4(0, 0, 1, 1);
var white = new Vector4(1, 1, 1, 1);

{{< /highlight >}}

إذا كنت ترغب في تعيين أحمر لنقطتي التحكم 0 و 1 ، والأخضر لنقطتي التحكم 2 و 3 ، والأزرق لنقطتي التحكم 4 و 5 ، والأبيض لنقطتي التحكم 6 و 7 ، يمكنك تحقيق ذلك باستخدام الطريقة التالية:

{{< highlight "csharp" >}}
vertexColor.ReferenceMode = ReferenceMode.Direct;
vertexColor.Data.Add(red); // 0
vertexColor.Data.Add(red); // 1
vertexColor.Data.Add(green); // 2
vertexColor.Data.Add(green); // 3
vertexColor.Data.Add(blue); // 4
vertexColor.Data.Add(blue); // 5
vertexColor.Data.Add(white); // 6
vertexColor.Data.Add(white); // 7
{{< /highlight >}}

لتعيين الألوان للتحكم في النقاط بكفاءة وتقليل استهلاك الذاكرة ، يمكنك استخدام المؤشرات للإشارة إلى الألوان. من خلال تحديد الألوان بشكل منفصل ثم الرجوع إليها بمؤشرات ، يمكنك تقليل التكرار. إليك كيف يمكنك تحقيق ذلك:

أولاً ، حدد 4 ألوان في نوع Vector4 للألوان الفريدة ، ثم استخدم صفيف من 8 مؤشرات لتعيين هذه الألوان لكل نقطة تحكم:

{{< highlight "csharp" >}}
vertexColor.ReferenceMode = ReferenceMode.IndexToDirect;
vertexColor.Data.Add(red);
vertexColor.Data.Add(green);
vertexColor.Data.Add(blue);
vertexColor.Data.Add(white);

vertexColor.SetIndices(new int[] { 0, 0, 1, 1, 2, 2, 3, 3 });
{{< /highlight >}}

في هذا النهج:

1. تعريف الألوان الفريدة: يتم تعريف 4 ألوان فقط (أحمر ، أخضر ، أزرق ، أبيض) كمثيلات Vector4.
1. إنشاء صفيف مؤشر اللون: يتم استخدام مجموعة من 8 مؤشرات للإشارة إلى هذه الألوان الأربعة لكل نقطة تحكم.
1. ألوان الخريطة باستخدام المؤشرات: بالرجوع إلى الألوان من خلال المؤشرات ، يمكنك تقليل استهلاك الذاكرة ، حيث يتم تخزين كل لون مرة واحدة وإعادة استخدامه عبر نقاط تحكم متعددة.

تعمل هذه الطريقة على تحسين استخدام الذاكرة عن طريق تقليل تخزين البيانات الزائد ، مما يجعل طراز 3D أكثر كفاءة.