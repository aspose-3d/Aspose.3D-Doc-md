---
title: MappingMode и ReferenceMode объясняет
type: docs
weight: 10
url: /ru/net/mapping-mode-and-reference-mode-explains
description: Используя Aspose.3D for .NET, разработчики могут определить сетку с различными элементами данных вершин, здесь мы объясняем, как сопоставить данные с компонентом сетки и повторно использовать данные.
---
{{% alert color="primary" %}}

Используя [Aspose.3D for .NET](https://products.aspose.com/3d/net/), разработчики могут определять сетки с различными элементами данных вершин, включая нормали, цвета и веса. Aspose.3D предлагает два механизма оптимизации повторного использования данных: `MappingMode` и `ReferenceMode`. Эти механизмы предназначены для минимизации занимаемой памяти ячеек, особенно в расширенных форматах, таких как FBX и USD. Режим сопоставления позволяет эффективно отображать данные вершин компонентам сетки, в то время как режим ReferenceMode облегчает привязку данных вершинных элементов к нескольким компонентам сетки. Вместе эти функции повышают производительность и эффективность памяти, делая Aspose.3D мощным инструментом для обработки сложных моделей 3D в приложениях .NET.

{{% /alert %}}



###  `MappingMode` объясняет

 `MappingMode` определяет, как данные элемента сопоставлены с поверхностью геометрии в Aspose.3D for .NET. Он предоставляет различные способы определения этого сопоставления:

1. **ControlPoint**, Каждый элемент данных сопоставляется с контрольной точкой геометрии. Этот режим гарантирует, что каждая контрольная точка, которая определяет форму геометрии, связана с конкретным элементом данных.
1. **Полигонвертекс**, Данные сопоставлены с вершиной многоугольника. В случаях, когда контрольная точка является общей для нескольких многоугольников, каждый экземпляр контрольной точки, как он появляется в разных многоугольников, будет иметь свои собственные различные данные. Это гарантирует, что даже общие контрольные точки могут иметь уникальные данные, когда они служат вершинами для разных полигонов.
1. **Полигон**, Данные сопоставлены со всем многоугольником. Это означает, что все вершины многоугольника имеют один и тот же элемент данных. Этот режим полезен, когда однородные данные должны быть применены ко всей поверхности многоугольника, обеспечивая согласованность внутри многоугольника.
1. **Край**, Данные сопоставлены с краями геометрии. Каждая конечная точка ребра использует одни и те же данные, обеспечивая способ применения однородных данных к ребрам, позволяя при этом различать данные для разных ребер. Это может быть особенно полезно для определения характеристик, характерных для кромок, таких как значения складок или атрибуты на основе кромок.
1. **AllSame**, Один элемент данных сопоставляется со всей поверхностью геометрии. Независимо от того, интерпретируются ли данные как контрольные точки, вершины многоугольника или конечные точки ребра, одно и то же значение данных применяется равномерно ко всем элементам. Этот режим идеально подходит для сценариев, в которых постоянное значение необходимо поддерживать по всей геометрии, обеспечивая единый атрибут по всей модели 3D.




###  `ReferenceMode` объясняет
 `ReferenceMode` определяет, следует ли повторно использовать данные по индексам, для `ReferenceMode` есть три политики:

1.**Прямой**, Данные имеют прямую ссылку и хранятся в свойстве `VertexElement` `Data`.
1.**Индекстодирект**, Данные ссылаются по индексу, а затем доступны по индексу в списке данных `VertexElement`.
1.**Индекс**, data is only referenced by index, now only the `VertexElementMaterial` use this reference mode, this is similar to `IndexToDirect` but the differences is the materials are defined under the `Node`'s property `Materials`, not in the `VertexElementMaterial`, all `VertexElement` only works with primitive data.



Например, дано определение куба:

{{< highlight "csharp" >}}
var cube = new Mesh();
Vector4[] controlPoints = new Vector4[]
{
    new Vector4( -5.0, 0.0, 5.0, 1.0),
    new Vector4( 5.0, 0.0, 5.0, 1.0),
    new Vector4( 5.0, 10.0, 5.0, 1.0),
    new Vector4( -5.0, 10.0, 5.0, 1.0),
    new Vector4( -5.0, 0.0, -5.0, 1.0),
    new Vector4( 5.0, 0.0, -5.0, 1.0),
    new Vector4( 5.0, 10.0, -5.0, 1.0),
    new Vector4( -5.0, 10.0, -5.0, 1.0)
};
cube.ControlPoints.AddRange(controlPoints);

// Front face (Z+)
cube.CreatePolygon(new int[] { 0, 1, 2, 3 });
// Right side (X+)
cube.CreatePolygon(new int[] { 1, 5, 6, 2 });
// Back face (Z-)
cube.CreatePolygon(new int[] { 5, 4, 7, 6 });
// Left side (X-)
cube.CreatePolygon(new int[] { 4, 0, 3, 7 });
// Bottom face (Y-)
cube.CreatePolygon(new int[] { 0, 4, 5, 1 });
// Top face (Y+)
cube.CreatePolygon(new int[] { 3, 2, 6, 7 });

var vertexColor = (VertexElementVertexColor) cube.CreateElement(VertexElementType.VertexColor);
vertexColor.MappingMode = MappingMode.ControlPoint;
var red = new Vector4(1, 0, 0, 1);
var green = new Vector4(0, 1, 0, 1);
var blue = new Vector4(0, 0, 1, 1);
var white = new Vector4(1, 1, 1, 1);

{{< /highlight >}}

Если вы хотите назначить красный цвет контрольным точкам 0 и 1, зеленый-контрольным точкам 2 и 3, синий-контрольным точкам 4 и 5, а белый-контрольным точкам 6 и 7, вы можете добиться этого следующим образом:

{{< highlight "csharp" >}}
vertexColor.ReferenceMode = ReferenceMode.Direct;
vertexColor.Data.Add(red); // 0
vertexColor.Data.Add(red); // 1
vertexColor.Data.Add(green); // 2
vertexColor.Data.Add(green); // 3
vertexColor.Data.Add(blue); // 4
vertexColor.Data.Add(blue); // 5
vertexColor.Data.Add(white); // 6
vertexColor.Data.Add(white); // 7
{{< /highlight >}}

Для эффективного назначения цветов контрольным точкам и снижения потребления памяти можно использовать индексы для ссылки на цвета. Определяя цвета отдельно, а затем ссылаясь на них с индексами, вы можете минимизировать избыточность. Вот как вы можете этого добиться:

Сначала определите 4 вида цветов в типе Vector4 для уникальных цветов, а затем используйте массив из 8 индексов, чтобы назначить эти цвета каждой контрольной точке:

{{< highlight "csharp" >}}
vertexColor.ReferenceMode = ReferenceMode.IndexToDirect;
vertexColor.Data.Add(red);
vertexColor.Data.Add(green);
vertexColor.Data.Add(blue);
vertexColor.Data.Add(white);

vertexColor.SetIndices(new int[] { 0, 0, 1, 1, 2, 2, 3, 3 });
{{< /highlight >}}

При таком подходе:

1. Определите уникальные цвета: Только 4 вида цветов определены (красный, зеленый, синий, белый) как экземпляры Vector4.
1. Создайте массив цветовых индексов: массив из 8 индексов используется для ссылки на них 4 вида цветов для каждой контрольной точки.
1. Сопоставление цветов с помощью индексов: Ссылаясь на цвета с помощью индексов, вы уменьшаете потребление памяти, поскольку каждый цвет сохраняется один раз и повторно используется в нескольких контрольных точках.

Этот метод оптимизирует использование памяти за счет сокращения избыточного хранилища данных, делая вашу модель 3D более эффективной.